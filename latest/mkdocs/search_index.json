{
    "docs": [
        {
            "location": "/", 
            "text": "StochasticDualDynamicProgramming.jl Documentation\n\n\nThis packages aims at providing an implementation of SDDP that is both efficient and modular/flexible. It features the following:\n\n\n\n\nSupport for unfeasible problem by generating a feasibility cut.\n\n\nSupport for unbounded problem by using an unbounded ray.\n\n\nSupport for a variety of cut pruning algorithm through the \nCutPruners\n package.\n\n\nSupport for any linear or conic solvers available through \nMathProgBase\n; see \nJuliaOpt's webpage\n for a list.\n\n\nSupport modeling the problem using the \nStructJuMP modeling interface\n.\n\n\nSupport specifying the problem using a low-level interface. This is used for example by the \nEntropicCone\n package.\n\n\n\n\nThe \nSDDP\n algorithm can be run from any node of the lattice of problems using the following function:\n\n\n#\n\n\nStochasticDualDynamicProgramming.SDDP\n \n \nMethod\n.\n\n\nSDDP(g, num_stages; K, verbose, stopcrit, pathsampler, ztol)\n\n\n\n\n\nRuns the SDDP algorithms on the lattice given by \ng\n. The algorithm will do iterations until \nstopcrit\n decides to stop or when the root node is infeasible. In each iterations, \nK\n paths will be explored up to \nnum_stages\n stages. The paths will be selected according to \npathsampler\n and equivalent paths might be merged if their difference is smaller than \nztol\n. The parameter \nztol\n is also used to check whether a new cut is useful.\n\n\nsource\n\n\nThis lattice can be built from a \nStructJuMP\n model using the following function:\n\n\nmodel2lattice(m::JuMP.Model, num_stages, solver, pruningalgo::CutPruners.AbstractCutPruningAlgo, cutmode::Symbol, newcut::Symbol)\n\n\n\n\n\n\nIndex\n\n\n\n\nStochasticDualDynamicProgramming.AndStoppingCriterion\n\n\nStochasticDualDynamicProgramming.CutLimit\n\n\nStochasticDualDynamicProgramming.IterLimit\n\n\nStochasticDualDynamicProgramming.OrStoppingCriterion\n\n\nStochasticDualDynamicProgramming.Pereira\n\n\nStochasticDualDynamicProgramming.SDDP\n\n\nStochasticDualDynamicProgramming.stop", 
            "title": "Home"
        }, 
        {
            "location": "/#stochasticdualdynamicprogrammingjl-documentation", 
            "text": "This packages aims at providing an implementation of SDDP that is both efficient and modular/flexible. It features the following:   Support for unfeasible problem by generating a feasibility cut.  Support for unbounded problem by using an unbounded ray.  Support for a variety of cut pruning algorithm through the  CutPruners  package.  Support for any linear or conic solvers available through  MathProgBase ; see  JuliaOpt's webpage  for a list.  Support modeling the problem using the  StructJuMP modeling interface .  Support specifying the problem using a low-level interface. This is used for example by the  EntropicCone  package.   The  SDDP  algorithm can be run from any node of the lattice of problems using the following function:  #  StochasticDualDynamicProgramming.SDDP     Method .  SDDP(g, num_stages; K, verbose, stopcrit, pathsampler, ztol)  Runs the SDDP algorithms on the lattice given by  g . The algorithm will do iterations until  stopcrit  decides to stop or when the root node is infeasible. In each iterations,  K  paths will be explored up to  num_stages  stages. The paths will be selected according to  pathsampler  and equivalent paths might be merged if their difference is smaller than  ztol . The parameter  ztol  is also used to check whether a new cut is useful.  source  This lattice can be built from a  StructJuMP  model using the following function:  model2lattice(m::JuMP.Model, num_stages, solver, pruningalgo::CutPruners.AbstractCutPruningAlgo, cutmode::Symbol, newcut::Symbol)", 
            "title": "StochasticDualDynamicProgramming.jl Documentation"
        }, 
        {
            "location": "/#index", 
            "text": "StochasticDualDynamicProgramming.AndStoppingCriterion  StochasticDualDynamicProgramming.CutLimit  StochasticDualDynamicProgramming.IterLimit  StochasticDualDynamicProgramming.OrStoppingCriterion  StochasticDualDynamicProgramming.Pereira  StochasticDualDynamicProgramming.SDDP  StochasticDualDynamicProgramming.stop", 
            "title": "Index"
        }, 
        {
            "location": "/stopcrit/", 
            "text": "Stopping Criterion\n\n\n#\n\n\nStochasticDualDynamicProgramming.stop\n \n \nMethod\n.\n\n\nstop(s, stats, totalstats)\n\n\n\n\n\nReturns whether the SDDP algorithm should stop. If \ntotalstats.niterations\n is 0, no iteration has already been done, otherwise, the \nniterations\nth iteration has just finished. This iteration used \nstats.npaths\n paths and generated \nstats.nfcuts\n (resp. \nstats.nocuts\n) new feasibility (resp. optimality) cuts. The lower bound is now \ntotalstats.lowerbound\n and the upper bound has mean \ntotalstats.upperbound\n and variance \ntotalstats.\u03c3_UB\n.\n\n\nsource\n\n\n#\n\n\nStochasticDualDynamicProgramming.OrStoppingCriterion\n \n \nType\n.\n\n\ntype OrStoppingCriterion \n: StochasticDualDynamicProgramming.AbstractStoppingCriterion\n\n\n\n\nStops if \nlhs\n \nor\n \nrhs\n want to stop.\n\n\nsource\n\n\n#\n\n\nStochasticDualDynamicProgramming.AndStoppingCriterion\n \n \nType\n.\n\n\ntype AndStoppingCriterion \n: StochasticDualDynamicProgramming.AbstractStoppingCriterion\n\n\n\n\nStops if \nlhs\n \nand\n \nrhs\n want to stop.\n\n\nsource\n\n\n#\n\n\nStochasticDualDynamicProgramming.IterLimit\n \n \nType\n.\n\n\ntype IterLimit \n: StochasticDualDynamicProgramming.AbstractStoppingCriterion\n\n\n\n\nStops if \niter\n \u2267 \nlimit\n.\n\n\nsource\n\n\n#\n\n\nStochasticDualDynamicProgramming.CutLimit\n \n \nType\n.\n\n\ntype CutLimit \n: StochasticDualDynamicProgramming.AbstractStoppingCriterion\n\n\n\n\nStops if there was less than or equal to \nlimit\n cuts added in the iteration. For instance, \nCutLimit(0)\n stops when there are no cuts added.\n\n\nsource\n\n\n#\n\n\nStochasticDualDynamicProgramming.Pereira\n \n \nType\n.\n\n\ntype Pereira \n: StochasticDualDynamicProgramming.AbstractStoppingCriterion\n\n\n\n\nStops if \nz_UB - \u03b1 * \u03c3/\u221aK - tol \n z_LB \n z_UB + \u03b1 * \u03c3/\u221aK + tol\n and \n\u03c3 / \u221aK \n \u03b2 * max(1, |z_LB|))\n\n\nsource", 
            "title": "Stopping Criterion"
        }, 
        {
            "location": "/stopcrit/#stopping-criterion", 
            "text": "#  StochasticDualDynamicProgramming.stop     Method .  stop(s, stats, totalstats)  Returns whether the SDDP algorithm should stop. If  totalstats.niterations  is 0, no iteration has already been done, otherwise, the  niterations th iteration has just finished. This iteration used  stats.npaths  paths and generated  stats.nfcuts  (resp.  stats.nocuts ) new feasibility (resp. optimality) cuts. The lower bound is now  totalstats.lowerbound  and the upper bound has mean  totalstats.upperbound  and variance  totalstats.\u03c3_UB .  source  #  StochasticDualDynamicProgramming.OrStoppingCriterion     Type .  type OrStoppingCriterion  : StochasticDualDynamicProgramming.AbstractStoppingCriterion  Stops if  lhs   or   rhs  want to stop.  source  #  StochasticDualDynamicProgramming.AndStoppingCriterion     Type .  type AndStoppingCriterion  : StochasticDualDynamicProgramming.AbstractStoppingCriterion  Stops if  lhs   and   rhs  want to stop.  source  #  StochasticDualDynamicProgramming.IterLimit     Type .  type IterLimit  : StochasticDualDynamicProgramming.AbstractStoppingCriterion  Stops if  iter  \u2267  limit .  source  #  StochasticDualDynamicProgramming.CutLimit     Type .  type CutLimit  : StochasticDualDynamicProgramming.AbstractStoppingCriterion  Stops if there was less than or equal to  limit  cuts added in the iteration. For instance,  CutLimit(0)  stops when there are no cuts added.  source  #  StochasticDualDynamicProgramming.Pereira     Type .  type Pereira  : StochasticDualDynamicProgramming.AbstractStoppingCriterion  Stops if  z_UB - \u03b1 * \u03c3/\u221aK - tol   z_LB   z_UB + \u03b1 * \u03c3/\u221aK + tol  and  \u03c3 / \u221aK   \u03b2 * max(1, |z_LB|))  source", 
            "title": "Stopping Criterion"
        }, 
        {
            "location": "/quickstart/", 
            "text": "A first example : Production Planning\n\n\nIn this quick start guide, we show how to run the \nFAST quick start example\n using this package. We guide you through each step of the modeling separately. The full example can be found \nin the test\n.\n\n\nWe start by setting the different constants\n\n\nconst num_stages = 2\nconst numScen = 2\nconst C = 1\nconst P = 2\nconst d = [2, 3]\n\n\n\n\nWe now model the master problem using \nStructJuMP\n.\n\n\nusing StructJuMP\nm1 = StructuredModel(num_scenarios=numScen)\n@variable(m1, x \n= 0)\n@objective(m1, Min, C * x)\n\n\n\n\nFor each of the two scenarios we need to create a \nStructJuMP\n model specifying that \nm1\n is the parent and that the scenario has probability \n1/2\n.\n\n\nfor \u03be in 1:numScen\n    m2 = StructuredModel(parent=m1, prob=1/2, id=\u03be)\n    @variable(m2, s \n= 0)\n    @constraints m2 begin\n        s \n= d[\u03be]\n        s \n= x\n    end\n    @objective(m2, Max, P * s)\nend\n\n\n\n\nThis structured model need to be transformed into an appropriate structure to run SDDP on it. This is achieved by \nmodel2lattice\n:\n\n\nusing GLPKMathProgInterface\nconst solver = GLPKMathProgInterface.GLPKSolverLP()\nusing CutPruners\nconst pruner = AvgCutPruningAlgo(-1)\nusing StochasticDualDynamicProgramming\nlattice = model2lattice(m1, num_stages, solver, pruner)\n\n\n\n\nIn this example, we have chosen the \nGLPK\n solver but you can use any LP solver listed in the table of the \nJuliaOpt's webpage\n.\n\n\nYou can now run the sddp algorithm on it using \nSDDP\n:\n\n\nsol = SDDP(lattice, num_stages, K = 2, stopcrit = Pereira(0.1) | IterLimit(10))\n\n\n\n\nWe are using 2 forward paths per iteration and we stop either after 10 iterations or once the pereira criterion is satisfied with $\\alpha = 0.1$.\n\n\nWe can verify that the algorithm have found the right value by inspecting the solution:\n\n\n@show sol.objval # sol.objval = -2.0", 
            "title": "Quick Start"
        }, 
        {
            "location": "/quickstart/#a-first-example-production-planning", 
            "text": "In this quick start guide, we show how to run the  FAST quick start example  using this package. We guide you through each step of the modeling separately. The full example can be found  in the test .  We start by setting the different constants  const num_stages = 2\nconst numScen = 2\nconst C = 1\nconst P = 2\nconst d = [2, 3]  We now model the master problem using  StructJuMP .  using StructJuMP\nm1 = StructuredModel(num_scenarios=numScen)\n@variable(m1, x  = 0)\n@objective(m1, Min, C * x)  For each of the two scenarios we need to create a  StructJuMP  model specifying that  m1  is the parent and that the scenario has probability  1/2 .  for \u03be in 1:numScen\n    m2 = StructuredModel(parent=m1, prob=1/2, id=\u03be)\n    @variable(m2, s  = 0)\n    @constraints m2 begin\n        s  = d[\u03be]\n        s  = x\n    end\n    @objective(m2, Max, P * s)\nend  This structured model need to be transformed into an appropriate structure to run SDDP on it. This is achieved by  model2lattice :  using GLPKMathProgInterface\nconst solver = GLPKMathProgInterface.GLPKSolverLP()\nusing CutPruners\nconst pruner = AvgCutPruningAlgo(-1)\nusing StochasticDualDynamicProgramming\nlattice = model2lattice(m1, num_stages, solver, pruner)  In this example, we have chosen the  GLPK  solver but you can use any LP solver listed in the table of the  JuliaOpt's webpage .  You can now run the sddp algorithm on it using  SDDP :  sol = SDDP(lattice, num_stages, K = 2, stopcrit = Pereira(0.1) | IterLimit(10))  We are using 2 forward paths per iteration and we stop either after 10 iterations or once the pereira criterion is satisfied with $\\alpha = 0.1$.  We can verify that the algorithm have found the right value by inspecting the solution:  @show sol.objval # sol.objval = -2.0", 
            "title": "A first example : Production Planning"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Hydro Thermal Scheduling\n\n\nIn this tutorial, we show how to run the \nFAST tutorial example\n using this package. The big difference between this example and the example quickstart example is that in this example we will model serial independence. There will be 5 stages and 2 scenarios per stages except for the first stage which has only one scenario. Each pair of scenario will have the same parent.\n\n\nWe start by setting the constants:\n\n\nconst num_stages = 5\nconst numScen = 2\nconst C = 5\nconst V = 8\nconst d = 6\nconst r = [2, 10]\n\n\n\n\nWe now create a matrix to store all the variables of all the models. This allows us to use the variables of other models from a given model. We also create an array of the first model of each stage to give play the role of parent for the models of the next stage.\n\n\nusing StructJuMP\nx = Matrix{JuMP.Variable}(num_stages, numScen)\ny = Matrix{JuMP.Variable}(num_stages, numScen)\np = Matrix{JuMP.Variable}(num_stages, numScen)\nmodels = Vector{JuMP.Model}(num_stages)\n\n\n\n\nNow, we create all the models. Note that each model declares that its parent is the first model (i.e. the model \n\u03be == 1\n) of the previous stage. Hence if it is not the first model, it also declares that it has the same children than the first model of its stage. This is how serial independence is modeled in \nStructJuMP\n.\n\n\nfor s in 1:num_stages\n    for \u03be in 1:(s == 1 ? 1 : numScen) # for the first stage there is only 1 scenario\n        if s == 1\n            model = StructuredModel(num_scenarios=numScen)\n        else\n            model = StructuredModel(parent=models[s-1], prob=1/2, same_children_as=(\u03be == 1 ? nothing : models[s]), id=\u03be, num_scenarios=(s == num_stages ? 0 : numScen))\n        end\n        x[s, \u03be] = @variable(model, lowerbound=0, upperbound=V)\n        y[s, \u03be] = @variable(model, lowerbound=0)\n        p[s, \u03be] = @variable(model, lowerbound=0)\n        if s \n 1\n            @constraint(model, x[s, \u03be] \n= x[s-1, 1] + r[\u03be] - y[s, \u03be])\n        else\n            @constraint(model, x[s, \u03be] \n= mean(r) - y[s, \u03be])\n        end\n        @constraint(model, p[s, \u03be] + y[s, \u03be] \n= d)\n        @objective(model, Min, C * p[s, \u03be])\n        # models[s] contains the first model only\n        if \u03be == 1\n            models[s] = model\n        end\n    end\nend\n\n\n\n\nWe now create the lattice, note that the master problem is \nmodels[1]\n.\n\n\nusing GLPKMathProgInterface\nconst solver = GLPKMathProgInterface.GLPKSolverLP()\nusing CutPruners\nconst pruner = AvgCutPruningAlgo(-1)\nusing StochasticDualDynamicProgramming\nlattice = model2lattice(models[1], num_stages, solver, pruner)\n\n\n\n\nThe SDDP algorithm can now be run on the lattice:\n\n\nsol = SDDP(lattice, num_stages, K = 16, stopcrit = Pereira(2., 0.5) | IterLimit(10))", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#hydro-thermal-scheduling", 
            "text": "In this tutorial, we show how to run the  FAST tutorial example  using this package. The big difference between this example and the example quickstart example is that in this example we will model serial independence. There will be 5 stages and 2 scenarios per stages except for the first stage which has only one scenario. Each pair of scenario will have the same parent.  We start by setting the constants:  const num_stages = 5\nconst numScen = 2\nconst C = 5\nconst V = 8\nconst d = 6\nconst r = [2, 10]  We now create a matrix to store all the variables of all the models. This allows us to use the variables of other models from a given model. We also create an array of the first model of each stage to give play the role of parent for the models of the next stage.  using StructJuMP\nx = Matrix{JuMP.Variable}(num_stages, numScen)\ny = Matrix{JuMP.Variable}(num_stages, numScen)\np = Matrix{JuMP.Variable}(num_stages, numScen)\nmodels = Vector{JuMP.Model}(num_stages)  Now, we create all the models. Note that each model declares that its parent is the first model (i.e. the model  \u03be == 1 ) of the previous stage. Hence if it is not the first model, it also declares that it has the same children than the first model of its stage. This is how serial independence is modeled in  StructJuMP .  for s in 1:num_stages\n    for \u03be in 1:(s == 1 ? 1 : numScen) # for the first stage there is only 1 scenario\n        if s == 1\n            model = StructuredModel(num_scenarios=numScen)\n        else\n            model = StructuredModel(parent=models[s-1], prob=1/2, same_children_as=(\u03be == 1 ? nothing : models[s]), id=\u03be, num_scenarios=(s == num_stages ? 0 : numScen))\n        end\n        x[s, \u03be] = @variable(model, lowerbound=0, upperbound=V)\n        y[s, \u03be] = @variable(model, lowerbound=0)\n        p[s, \u03be] = @variable(model, lowerbound=0)\n        if s   1\n            @constraint(model, x[s, \u03be]  = x[s-1, 1] + r[\u03be] - y[s, \u03be])\n        else\n            @constraint(model, x[s, \u03be]  = mean(r) - y[s, \u03be])\n        end\n        @constraint(model, p[s, \u03be] + y[s, \u03be]  = d)\n        @objective(model, Min, C * p[s, \u03be])\n        # models[s] contains the first model only\n        if \u03be == 1\n            models[s] = model\n        end\n    end\nend  We now create the lattice, note that the master problem is  models[1] .  using GLPKMathProgInterface\nconst solver = GLPKMathProgInterface.GLPKSolverLP()\nusing CutPruners\nconst pruner = AvgCutPruningAlgo(-1)\nusing StochasticDualDynamicProgramming\nlattice = model2lattice(models[1], num_stages, solver, pruner)  The SDDP algorithm can now be run on the lattice:  sol = SDDP(lattice, num_stages, K = 16, stopcrit = Pereira(2., 0.5) | IterLimit(10))", 
            "title": "Hydro Thermal Scheduling"
        }
    ]
}