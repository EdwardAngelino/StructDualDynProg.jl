{
    "docs": [
        {
            "location": "/", 
            "text": "StochasticDualDynamicProgramming.jl Documentation\n\n\nThis packages aims at providing an implementation of SDDP that is both efficient and modular/flexible. It features the following:\n\n\n\n\nSupport for unfeasible problem by generating a feasibility cut.\n\n\nSupport for unbounded problem by using an unbounded ray.\n\n\nSupport for a variety of cut pruning algorithm through the \nCutPruners\n package.\n\n\nSupport for any linear or conic solvers available through \nMathProgBase\n; see \nJuliaOpt's webpage\n for a list.\n\n\nSupport modeling the problem using the \nStructJuMP modeling interface\n.\n\n\nSupport specifying the problem using a low-level interface. This is used for example by the \nEntropicCone\n package.\n\n\n\n\nThe \nSDDP\n algorithm can be run from any node of the lattice of problems using the following function:\n\n\n#\n\n\nStochasticDualDynamicProgramming.SDDP\n \n \nMethod\n.\n\n\nSDDP(g, num_stages; K, verbose, pathsel, stopcrit, ztol)\n\n\n\n\n\nRuns the SDDP algorithms on the lattice given by \ng\n. The algorithm will do iterations until \nstopcrit\n decides to stop or when the root node is infeasible. In each iterations, \nK\n paths will be explored up to \nnum_stages\n stages. The paths will be selected according to \npathsel\n and equivalent paths might be merged if their difference is smaller than \nztol\n. The parameter \nztol\n is also used to check whether a new cut is useful.\n\n\nsource\n\n\nThis lattice can be built from a \nStructJuMP\n model using the following function:\n\n\n#\n\n\nStochasticDualDynamicProgramming.model2lattice\n \n \nMethod\n.\n\n\nmodel2lattice(m, num_stages, solver, pruningalgo)\nmodel2lattice(m, num_stages, solver, pruningalgo, cutmode)\nmodel2lattice(m, num_stages, solver, pruningalgo, cutmode, newcut)\n\n\n\n\n\nTransforms a \nStructJuMP\n model \nm\n into a lattice that can be used by the SDDP algorithm.\n\n\nsource\n\n\n\n\nIndex\n\n\n\n\nStochasticDualDynamicProgramming.AndStoppingCriterion\n\n\nStochasticDualDynamicProgramming.CutLimit\n\n\nStochasticDualDynamicProgramming.IterLimit\n\n\nStochasticDualDynamicProgramming.OrStoppingCriterion\n\n\nStochasticDualDynamicProgramming.Pereira\n\n\nStochasticDualDynamicProgramming.SDDP\n\n\nStochasticDualDynamicProgramming.model2lattice\n\n\nStochasticDualDynamicProgramming.stop", 
            "title": "Home"
        }, 
        {
            "location": "/#stochasticdualdynamicprogrammingjl-documentation", 
            "text": "This packages aims at providing an implementation of SDDP that is both efficient and modular/flexible. It features the following:   Support for unfeasible problem by generating a feasibility cut.  Support for unbounded problem by using an unbounded ray.  Support for a variety of cut pruning algorithm through the  CutPruners  package.  Support for any linear or conic solvers available through  MathProgBase ; see  JuliaOpt's webpage  for a list.  Support modeling the problem using the  StructJuMP modeling interface .  Support specifying the problem using a low-level interface. This is used for example by the  EntropicCone  package.   The  SDDP  algorithm can be run from any node of the lattice of problems using the following function:  #  StochasticDualDynamicProgramming.SDDP     Method .  SDDP(g, num_stages; K, verbose, pathsel, stopcrit, ztol)  Runs the SDDP algorithms on the lattice given by  g . The algorithm will do iterations until  stopcrit  decides to stop or when the root node is infeasible. In each iterations,  K  paths will be explored up to  num_stages  stages. The paths will be selected according to  pathsel  and equivalent paths might be merged if their difference is smaller than  ztol . The parameter  ztol  is also used to check whether a new cut is useful.  source  This lattice can be built from a  StructJuMP  model using the following function:  #  StochasticDualDynamicProgramming.model2lattice     Method .  model2lattice(m, num_stages, solver, pruningalgo)\nmodel2lattice(m, num_stages, solver, pruningalgo, cutmode)\nmodel2lattice(m, num_stages, solver, pruningalgo, cutmode, newcut)  Transforms a  StructJuMP  model  m  into a lattice that can be used by the SDDP algorithm.  source", 
            "title": "StochasticDualDynamicProgramming.jl Documentation"
        }, 
        {
            "location": "/#index", 
            "text": "StochasticDualDynamicProgramming.AndStoppingCriterion  StochasticDualDynamicProgramming.CutLimit  StochasticDualDynamicProgramming.IterLimit  StochasticDualDynamicProgramming.OrStoppingCriterion  StochasticDualDynamicProgramming.Pereira  StochasticDualDynamicProgramming.SDDP  StochasticDualDynamicProgramming.model2lattice  StochasticDualDynamicProgramming.stop", 
            "title": "Index"
        }, 
        {
            "location": "/stopcrit/", 
            "text": "Stopping Criterion\n\n\n#\n\n\nStochasticDualDynamicProgramming.stop\n \n \nMethod\n.\n\n\nstop(s, stats, totalstats)\n\n\n\n\n\nReturns whether the SDDP algorithm should stop. If \ntotalstats.niterations\n is 0, no iteration has already been done, otherwise, the \nniterations\nth iteration has just finished. This iteration used \nstats.npaths\n paths and generated \nstats.nfcuts\n (resp. \nstats.nocuts\n) new feasibility (resp. optimality) cuts. The lower bound is now \ntotalstats.lowerbound\n and the upper bound has mean \ntotalstats.upperbound\n and variance \ntotalstats.\u03c3_UB\n.\n\n\nsource\n\n\n#\n\n\nStochasticDualDynamicProgramming.OrStoppingCriterion\n \n \nType\n.\n\n\ntype OrStoppingCriterion \n: StochasticDualDynamicProgramming.AbstractStoppingCriterion\n\n\n\n\nStops if \nlhs\n \nor\n \nrhs\n want to stop.\n\n\nsource\n\n\n#\n\n\nStochasticDualDynamicProgramming.AndStoppingCriterion\n \n \nType\n.\n\n\ntype AndStoppingCriterion \n: StochasticDualDynamicProgramming.AbstractStoppingCriterion\n\n\n\n\nStops if \nlhs\n \nand\n \nrhs\n want to stop.\n\n\nsource\n\n\n#\n\n\nStochasticDualDynamicProgramming.IterLimit\n \n \nType\n.\n\n\ntype IterLimit \n: StochasticDualDynamicProgramming.AbstractStoppingCriterion\n\n\n\n\nStops if \niter\n \u2267 \nlimit\n.\n\n\nsource\n\n\n#\n\n\nStochasticDualDynamicProgramming.CutLimit\n \n \nType\n.\n\n\ntype CutLimit \n: StochasticDualDynamicProgramming.AbstractStoppingCriterion\n\n\n\n\nStops if there was less than or equal to \nlimit\n cuts added in the iteration. For instance, \nCutLimit(0)\n stops when there are no cuts added.\n\n\nsource\n\n\n#\n\n\nStochasticDualDynamicProgramming.Pereira\n \n \nType\n.\n\n\ntype Pereira \n: StochasticDualDynamicProgramming.AbstractStoppingCriterion\n\n\n\n\nStops if \nz_UB - \u03b1 * \u03c3/\u221aK \n z_LB \n z_UB - \u03b1 * \u03c3/\u221aK\n and \n\u03c3 / \u221aK \n \u03b2 * max(1, |z_LB|))\n\n\nsource", 
            "title": "Stopping Criterion"
        }, 
        {
            "location": "/stopcrit/#stopping-criterion", 
            "text": "#  StochasticDualDynamicProgramming.stop     Method .  stop(s, stats, totalstats)  Returns whether the SDDP algorithm should stop. If  totalstats.niterations  is 0, no iteration has already been done, otherwise, the  niterations th iteration has just finished. This iteration used  stats.npaths  paths and generated  stats.nfcuts  (resp.  stats.nocuts ) new feasibility (resp. optimality) cuts. The lower bound is now  totalstats.lowerbound  and the upper bound has mean  totalstats.upperbound  and variance  totalstats.\u03c3_UB .  source  #  StochasticDualDynamicProgramming.OrStoppingCriterion     Type .  type OrStoppingCriterion  : StochasticDualDynamicProgramming.AbstractStoppingCriterion  Stops if  lhs   or   rhs  want to stop.  source  #  StochasticDualDynamicProgramming.AndStoppingCriterion     Type .  type AndStoppingCriterion  : StochasticDualDynamicProgramming.AbstractStoppingCriterion  Stops if  lhs   and   rhs  want to stop.  source  #  StochasticDualDynamicProgramming.IterLimit     Type .  type IterLimit  : StochasticDualDynamicProgramming.AbstractStoppingCriterion  Stops if  iter  \u2267  limit .  source  #  StochasticDualDynamicProgramming.CutLimit     Type .  type CutLimit  : StochasticDualDynamicProgramming.AbstractStoppingCriterion  Stops if there was less than or equal to  limit  cuts added in the iteration. For instance,  CutLimit(0)  stops when there are no cuts added.  source  #  StochasticDualDynamicProgramming.Pereira     Type .  type Pereira  : StochasticDualDynamicProgramming.AbstractStoppingCriterion  Stops if  z_UB - \u03b1 * \u03c3/\u221aK   z_LB   z_UB - \u03b1 * \u03c3/\u221aK  and  \u03c3 / \u221aK   \u03b2 * max(1, |z_LB|))  source", 
            "title": "Stopping Criterion"
        }
    ]
}