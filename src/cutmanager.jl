export AbstractCutManager

abstract AbstractCutManager{S}

function ncuts(man::AbstractCutManager)
  return length(get(man.cuts_de))
end

function isfeasibilitycut(man::AbstractCutManager, cut)
  if length(man.σs) < length(man.ρs)
    cut in man.σs
  else
    !(cut in man.ρs)
  end
end

function init!(man::AbstractCutManager, mycut_d, mycut_e)
  mycut = [mycut_d; mycut_e]
  man.trust = Float64[initialtrust(man, mc) for mc in mycut]
end

function start!(man::AbstractCutManager, cuts_D, cuts_E, cuts_d, cuts_e, mycut_d, mycut_e)
  man.nσ = length(cuts_d)
  man.nρ = length(cuts_e)
  man.cuts_DE = [cuts_D; cuts_E]
  man.cuts_de = [cuts_d; cuts_e]
  man.σs = collect(1:man.nσ)
  man.ρs = collect(man.nσ+(1:man.nρ))
  init!(man, mycut_d, mycut_e)
end

function isstarted(man::AbstractCutManager)
  @assert isnull(man.cuts_DE) == isnull(man.cuts_de)
  !isnull(man.cuts_DE)
end

# COMPARISON
gettrust(man::AbstractCutManager) = man.trust

function choosecutstoremove(man::AbstractCutManager, num)
  # MergeSort is stable so in case of equality, the oldest cut loose
  # However PartialQuickSort is a lot faster

  trust = gettrust(man)
  if num == 1
    [indmin(trust)]                   # indmin selects the oldest cut in case of tie -> good :)
  else
    sortperm(trust, alg=PartialQuickSort(num))[1:num] # PartialQuickSort is unstable ->  bad :(
  end
end

isbetter(man::AbstractCutManager, i::Int, mycut::Bool) = gettrust(man)[i] > initialtrust(man, mycut)

# CHANGE

# Add cut ax >= β
# If fc then it is a feasibility cut, otherwise it is an optimality cut
# If mycut then the cut has been added because of one of my trials
function addcuts!{S}(man::AbstractCutManager{S}, A::AbstractMatrix{S}, b::AbstractVector{S}, isfc::Bool, mycut::Vector{Bool})

  ncuts = size(A, 1)
  if man.maxncuts != -1 && ncuts(man)+ncuts > man.maxncuts
    # Need to remove some cuts
    J = choosecutstoremove(man, ncuts(man) + ncuts - man.maxncuts)
    #if man.trustman.bettercut(0, 0, mycut, man.nwith[J[end]], man.nused[J[end]], man.mycut[J[end]])
    take = 0
    j = length(J)
    nmycut = sum(mycut)
    while j > 0 && take < ncuts
      # I first try to see if the nmycut cuts generated by me can be taken
      # because they have better trust than the ncuts-nmycut others
      if isbetter(man, J[j], take < nmycut)
        j -= 1
      else
        take += 1
      end
    end
    if !isbetter(man, J[end], mycut)
      j = J[end]
      get(man.cuts_DE)[j,:] = a
      get(man.cuts_de)[j] = β
      replacecut!(man, j, mycut)
      cutadded = true
      needupdate_σsρs = isfc $ isfeasibilitycut(man, j)
    else
      cutadded = false
      needupdate_σsρs = false
    end
    J = J[1:end-1]

    if length(J) > 1 || needupdate_σsρs
      keep = ones(Bool, ncuts(man))
      keep[J] = false
      K = find(keep)
      isσcut = zeros(Bool, ncuts(man))
      isσcut[man.σs] = true
      if cutadded
        isσcut[j] = isfc
      end
      isσcut = isσcut[K]
      man.σs = (1:length(isσcut))[isσcut]
      man.ρs = (1:length(isσcut))[!isσcut]
      man.nσ = length(man.σs)
      man.nρ = length(man.ρs)
    end

    if length(J) > 1
      man.cuts_DE = get(man.cuts_DE)[K,:]
      man.cuts_de = get(man.cuts_de)[K]
      keeponly!(man, K)
    end

    cutadded ? :Replaced : :Ignored
  else
    # Just append cut
    if isfc
      append!(man.σs, man.nσ + man.nρ + (1:ncuts))
      man.nσ += ncuts
    else
      append!(man.ρs, man.nσ + man.nρ + (1:ncuts))
      man.nρ += ncuts
    end
    man.cuts_DE = [get(man.cuts_DE); A]
    man.cuts_de = [get(man.cuts_de); b]
    pushcut!(man, mycut)
    Symbol[:Pushed for i in 1:ncuts]
  end
end

function keeponly!(man::AbstractCutManager, K::Vector{Int})
  man.trust = man.trust[K]
end

function replacecut!(man::AbstractCutManager, j::Int, mycut::Bool)
  man.trust[j] = initialtrust(man, mycut)
end

function pushcut!(man::AbstractCutManager, mycut::Bool)
  push!(man.trust, initialtrust(man, mycut))
end
